# 算法 + 小黄书 = 大厂实习

## 用js刷leetcode的步骤


- 怎么学习算法
  - leetcode 热题 100 200+ 题目
  - 代码随想录 - 算法训练营

- 算法的核心效率
装机和品牌机 性价比
  衡量算法 时间复杂度 和 空间复杂度

- 不要急于刷题， 先打好算法基础
  - 大O 时间复杂度 空间复杂度
O(1)> O(n) >O(logn) >O(n^2) > O(n×m) > O(2^n)

- 时间复杂度是怎么计算的？
  - 计算的方法？
  - 代码的执行次数  T(n) Time 次数
  - 抓住主要矛盾，O(n)就是执行的趋势 忽略常数项 和 低次项
- 由执行次数T（n）可以推导出时间复杂度O（n）
  - 由边界理论， 输入规模无限大，时间复杂度表达的执行次数的增长**趋势**
    所以，系数忽略，抓住主要矛盾

- 算法不是解法， 而是 恰当或者更优的时间复杂度或空间复杂度的解法。
  比如 排序算法 冒泡排序 选择排序 插入排序 快速排序 归并排序 堆排序 希尔排序 计数排序 桶排序 基数排序 等等。
  排序 冒泡排序O(n^2)
  快排 平均O(nlogn) 最坏O(n^2)

空间复杂度
    算法在运行过程中占用的**额外**空间的大小。没有另外开辟空间，空间复杂度为O(1)


- 数据结构
  - 线性
    - 数组 最简单最好用的
      - 内置方法很多，开箱即用
        建议优先考虑数组，节点+指针比较复杂，容易出错
        除非 不连续
    
    - 栈，队列，链表  最常用的
  - 非线性
    - 树
    - 图

- 算法中如何定义一个数组
  new Arry(10)

- 访问和遍历
  - 访问 array[index] O(1) 链表则需要一个一个查 O(n)
  - 遍历  
    for
    for-each
    map
    